package postgres_test

import (
	"fmt"
	"testing"

	"github.com/google/go-cmp/cmp"
	_ "github.com/lib/pq"
	"github.com/livepeer/leaderboard-serverless/common"
	"github.com/livepeer/leaderboard-serverless/db"
	"github.com/livepeer/leaderboard-serverless/models"
	"github.com/livepeer/leaderboard-serverless/testutils"
)

func TestMain(m *testing.M) {
	testutils.TestMain(m)
}

func TestPostgresRegionsRefDataSetup(t *testing.T) {
	testutils.NewDB(t)

	regions, err := db.Store.Regions()
	if err != nil {
		t.Fatalf("Expected no error when retrieving regions, got %v", err)
	}

	if len(regions) == 0 {
		t.Fatalf("Failed to find the regions in the database.  They usually are generated by the migrations.")
	}

	common.Logger.Info("Found %d regions", len(regions))

	//create array to test with values "ATL", "MDW", "TOR"
	expectedRegions := []string{"ATL", "MDW", "TOR"}

	//loop over regions and check if one of the regions is the expected region
	foundTrans := 0
	foundAI := 0
	expectedTrans := 3
	expectedAI := 1
	for _, region := range regions {
		for _, expectedRegion := range expectedRegions {
			if region.Name == expectedRegion {
				if region.Type == models.Transcoding.String() {
					foundTrans++
				} else if region.Type == models.AI.String() {
					foundAI++
				}
				break
			}
		}
	}
	if foundTrans != expectedTrans {
		t.Fatalf("Expected to find %d Transcoding regions, found %d", expectedTrans, foundTrans)
	}
	if foundAI != expectedAI {
		t.Fatalf("Expected to find %d AI regions, found %d", expectedAI, foundAI)
	}
}

func TestPostgresInsertStats(t *testing.T) {

	type testCase struct {
		name     string
		getStats func() models.Stats
	}

	testCases := []testCase{
		{
			name:     "TranscodingStats",
			getStats: testutils.GetTranscodingStats,
		},
		{
			name:     "AIStats",
			getStats: testutils.GetAIStats,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			common.Logger.Info("Running test: %s", tc.name)
			testutils.NewDB(t)

			stats := tc.getStats()
			common.Logger.Info("%s test stats to be inserted: %v", tc.name, stats)

			ValidateStats(t, &stats)
		})
	}
}

func TestPostgresInsertRegions(t *testing.T) {

	type testCase struct {
		name    string
		regions []*models.Region
	}

	testCases := []testCase{
		{
			name:    "NewRegionInserts",
			regions: []*models.Region{testutils.GetNewRegion()},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			common.Logger.Info("Running test: %s", tc.name)
			testutils.NewDB(t)

			totalInserted, totalProcessed := db.Store.InsertRegions(tc.regions)
			if totalInserted != len(tc.regions) {
				t.Fatalf("expected all regions to be inserted but only %d of %d were inserted", totalInserted, len(tc.regions))
			}
			if totalProcessed != len(tc.regions) {
				t.Fatalf("expected all regions to be processed but only %d of %d were totalProcessed", totalProcessed, len(tc.regions))
			}
		})
	}
}

func TestPostgresAggregatedStats(t *testing.T) {

	aiStats := testutils.GetAIStats()

	//create a failed AI stats object
	aiStatsFailed := testutils.GetAIStats()
	aiStatsFailed.SuccessRate = 0

	//create a slow AI stats object
	aiStatsSlow := testutils.GetAIStats()
	aiStatsSlow.SuccessRate = 1
	aiStatsSlow.RoundTripTime = 15.2

	//create an AI stats object with a different Orchestrator
	aiStatsNewOrchAndRegion := testutils.GetAIStats()
	aiStatsNewOrchAndRegion.Orchestrator = "0x5c0e79538f4d17a668568c4031e4a1488d71df1b"
	aiStatsNewOrchAndRegion.Region = "FRA"

	//create an AI stats object with a different Orchestrator
	aiStatsNewOrch2AndPipeline := testutils.GetAIStats()
	aiStatsNewOrch2AndPipeline.Orchestrator = "0x7c0e79538f4d17a668568c4031e4a1488d71df1a"
	aiStatsNewOrch2AndPipeline.Model = "some/other-model"
	aiStatsNewOrch2AndPipeline.Pipeline = "some/other-pipeline"
	//empty out the following fields as they don't retrun from the aggr stats query
	aiStatsNewOrch2AndPipeline.Errors = nil
	aiStatsNewOrch2AndPipeline.ResponsePayload = ""
	aiStatsNewOrch2AndPipeline.InputParameters = ""

	type testCase struct {
		name          string
		statsQuery    *models.StatsQuery
		statsToTest   []models.Stats
		expectedStats []*models.Stats //optional; if not provided, the expected stats will be dynamically generated from the statsToTest
	}

	testCases := []testCase{
		{
			name: "Test with valid transcoding input and query params",
			statsQuery: &models.StatsQuery{
				Since: testutils.GetUnixTimeMinusTenSec(),
				Until: testutils.GetUnixTimeInFiveSec(),
			},
			statsToTest: []models.Stats{testutils.GetTranscodingStats()},
		},
		{
			name: "Test with valid AI input and query params",
			statsQuery: &models.StatsQuery{
				Since:    testutils.GetUnixTimeMinusTenSec(),
				Until:    testutils.GetUnixTimeInFiveSec(),
				Pipeline: aiStats.Pipeline,
				Model:    aiStats.Model,
			},
			statsToTest: []models.Stats{aiStats},
		},
		{
			name: "Test with multiple valid AI input and query params",
			statsQuery: &models.StatsQuery{
				Since:    testutils.GetUnixTimeMinusTenSec(),
				Until:    testutils.GetUnixTimeInFiveSec(),
				Pipeline: aiStats.Pipeline,
				Model:    aiStats.Model,
			},
			statsToTest: []models.Stats{aiStats, aiStatsFailed, aiStatsSlow},
			expectedStats: []*models.Stats{
				{
					Region:        "MDW",
					Orchestrator:  testutils.GetOrchestratorID(),
					SuccessRate:   0.3333333333333333,
					RoundTripTime: 6.54381758,
					Errors:        nil,
					Timestamp:     0,
					Model:         testutils.GetModel(),
					Pipeline:      testutils.GetPipeline(),
				},
			},
		},
		{
			name: "Test with multiple Orchs with valid AI input and query params",
			statsQuery: &models.StatsQuery{
				Since:    testutils.GetUnixTimeMinusTenSec(),
				Until:    testutils.GetUnixTimeInFiveSec(),
				Pipeline: aiStats.Pipeline,
				Model:    aiStats.Model,
			},
			statsToTest: []models.Stats{aiStats, aiStatsFailed, aiStatsSlow, aiStatsNewOrchAndRegion},
			expectedStats: []*models.Stats{
				{
					Region:        "MDW",
					Orchestrator:  testutils.GetOrchestratorID(),
					SuccessRate:   0.3333333333333333,
					RoundTripTime: 6.54381758,
					Errors:        nil,
					Timestamp:     0,
					Model:         testutils.GetModel(),
					Pipeline:      testutils.GetPipeline(),
				},
				{
					Region:        "FRA",
					Orchestrator:  "0x5c0e79538f4d17a668568c4031e4a1488d71df1b",
					RoundTripTime: 2.21572637,
					Model:         testutils.GetModel(),
					Pipeline:      testutils.GetPipeline(),
				},
			},
		},
		{
			name: "Test with multiple Orchs - variation 2 to test different averages scores from db",
			statsQuery: &models.StatsQuery{
				Since:    testutils.GetUnixTimeMinusTenSec(),
				Until:    testutils.GetUnixTimeInFiveSec(),
				Pipeline: aiStats.Pipeline,
				Model:    aiStats.Model,
			},
			statsToTest: []models.Stats{aiStats, aiStatsSlow, aiStatsNewOrchAndRegion},
			expectedStats: []*models.Stats{
				{
					Region:        "MDW",
					Orchestrator:  testutils.GetOrchestratorID(),
					SuccessRate:   0.5,
					RoundTripTime: 8.707863184999999,
					Errors:        nil,
					Timestamp:     0,
					Model:         testutils.GetModel(),
					Pipeline:      testutils.GetPipeline(),
				},
				{
					Region:        "FRA",
					Orchestrator:  "0x5c0e79538f4d17a668568c4031e4a1488d71df1b",
					RoundTripTime: 2.21572637,
					Model:         testutils.GetModel(),
					Pipeline:      testutils.GetPipeline(),
				},
			},
		},
		{
			name: "Test with multiple Orchs with different pipeline and model",
			statsQuery: &models.StatsQuery{
				Since:    testutils.GetUnixTimeMinusTenSec(),
				Until:    testutils.GetUnixTimeInFiveSec(),
				Pipeline: aiStatsNewOrch2AndPipeline.Pipeline,
				Model:    aiStatsNewOrch2AndPipeline.Model,
			},
			statsToTest:   []models.Stats{aiStats, aiStatsFailed, aiStatsSlow, aiStatsNewOrchAndRegion, aiStatsNewOrch2AndPipeline},
			expectedStats: []*models.Stats{&aiStatsNewOrch2AndPipeline},
		},
	}

	//run the tests in parallel
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			testutils.NewDB(t)
			common.Logger.Info("Running test: %s", tc.name)
			var expectedAggStats []*models.Stats
			for _, stats := range tc.statsToTest {

				//insert the stats object into the database
				for _, stats := range tc.statsToTest {
					if err := db.Store.InsertStats(&stats); err != nil {
						t.Fatalf("Unexpected error when inserting test stats: %v", err)
					}
				}

				if tc.expectedStats != nil {
					common.Logger.Info("Using expected stats from test case")
					expectedAggStats = tc.expectedStats
				} else {
					common.Logger.Info("Using dynamically generated expected stats")
					expectedAggStats = append(expectedAggStats, &models.Stats{
						Orchestrator:  stats.Orchestrator,
						Region:        stats.Region,
						SuccessRate:   stats.SuccessRate,
						SegDuration:   stats.SegDuration,
						RoundTripTime: stats.RoundTripTime,
						Model:         stats.Model,
						Pipeline:      stats.Pipeline,
					})
				}
			}

			aggregatedStatsResults, err := db.Store.AggregatedStats(tc.statsQuery)
			if err != nil {
				t.Fatalf("Expected no error when retrieving aggregated stats, got %v", err)
			}

			if aggregatedStatsResults == nil {
				common.Logger.Info("Found nil aggregated stats")
				t.Fatalf("Expected aggregated stats, got nil")
			}

			if !aggregatedStatsResults.HasResults() {
				t.Fatalf("Expected aggregated stats, got empty")
			}

			aggregatedStats := aggregatedStatsResults.Stats
			if len(aggregatedStats) != len(expectedAggStats) {
				t.Fatalf("Expected %d aggregated stats, got %d", len(expectedAggStats), len(aggregatedStats))
			} else if !cmp.Equal(aggregatedStats, expectedAggStats) {
				common.Logger.Info("Found %d aggregated stats", len(aggregatedStats))
				common.Logger.Info("Showing diff of expected and actual aggregated stats")
				fmt.Println(cmp.Diff(aggregatedStats, expectedAggStats))
				t.Fatalf("Expected aggregated stats of %v, got %v", expectedAggStats, aggregatedStats)
			}
		})
	}
}

func ValidateStats(t *testing.T, testStats *models.Stats) {

	//insert the stats object into the database
	if err := db.Store.InsertStats(testStats); err != nil {
		t.Fatalf("Unexpected error when inserting stats: %v", err)
	}

	common.Logger.Info("Inserted test stats object")

	//get the stats object from the database
	stats, err := db.Store.RawStats(&models.StatsQuery{
		Orchestrator: testStats.Orchestrator,
		//since 10 secs ago
		Since: testutils.GetUnixTimeMinusTenSec(),
		Until: testutils.GetUnixTimeInFiveSec(),

		Pipeline: testStats.Pipeline,
		Model:    testStats.Model,
	})
	if err != nil {
		t.Fatalf("Expected no error when retrieving raw stats, got %v", err)
	}

	//check if the stats object is not nil
	if stats == nil {
		t.Fatalf("Expected stats object, got nil")
	}
	if len(stats) == 0 {
		t.Fatalf("Expected non-empty stats, got empty")
	} else if !cmp.Equal(stats[0], testStats) {
		common.Logger.Info("Showing diff of expected and actual stats")
		fmt.Println(cmp.Diff(testStats, stats[0]))
		t.Fatalf("Expected %v, got %v", testStats, stats[0])
	}
}
